package main

import (
	"fmt"
	"log"
	"net/http"
	"os"
	"os/exec"
	"strings"

	"golang.org/x/sync/errgroup"
)

// TODO: refactor

func main() {
	log.Println("check environment")
	if err := checkEnvironment(); err != nil {
		log.Fatal("check environment failed:", err)
	}

	log.Println("build tree html")
	treeHTML, err := buildTreeHTML()
	if err != nil {
		log.Fatal("failed to build tree html:", err)
	}

	log.Println("build deps graph")
	depsGraph, err := buildDepsGraph()
	if err != nil {
		log.Fatal("failed to build deps graph:", err)
	}

	log.Println("paste deps to html")
	htmlPage, err := pasteDepsToHTML(treeHTML, depsGraph)
	if err != nil {
		log.Fatal("failed to paste deps to html:", err)
	}

	log.Println("hosting. visit http://localhost:8080")
	err = http.ListenAndServe(":8080", http.HandlerFunc(
		func(w http.ResponseWriter, r *http.Request) {
			w.Write(htmlPage)
		}))
	if err != nil {
		log.Fatal("listen and serve failed:", err)
	}
}

func checkEnvironment() error {
	cmd := exec.Command("tree")
	if cmd.Err != nil {
		return fmt.Errorf("lookup 'tree' util: %w", cmd.Err)
	}

	cmd = exec.Command("goda")
	if cmd.Err != nil {
		return fmt.Errorf("lookup 'goda' util https://github.com/loov/goda: %w", cmd.Err)
	}

	cmd = exec.Command("dot")
	if cmd.Err != nil {
		return fmt.Errorf("lookup 'dot' util, graphviz: %w", cmd.Err)
	}

	return nil
}

// buildTreeHTML uses 'tree' util to generate directory tree and basic html page.
// Was made via 'tree' because it was the shortest way to implement desired behaviour.
// TODO: replace to native go code in the future.
func buildTreeHTML() (page []byte, err error) {
	cmd := exec.Command("tree")
	if cmd.Err != nil {
		return nil, fmt.Errorf("command: %w", cmd.Err)
	}
	cmd.Args = append(cmd.Args, "--dirsfirst", "-d", "--sort", "name", "-C", "-H", "")

	data, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("command output: %w", err)
	}

	return data, nil
}

func buildDepsGraph() ([]byte, error) {
	log.Println("gather dependencies")
	cmdGoda := exec.Command("goda")
	if cmdGoda.Err != nil {
		return nil, fmt.Errorf("command goda: %w", cmdGoda.Err)
	}

	cmdGoda.Args = append(cmdGoda.Args, "graph", "-cluster", "-short", "./...:mod")

	godaOutputReader, err := cmdGoda.StdoutPipe()
	if err != nil {
		return nil, fmt.Errorf("command stdout pipe: %w", err)
	}

	// Async is needed to pipe goda output to graphviz
	eg := errgroup.Group{}
	eg.Go(func() error {
		err := cmdGoda.Run()
		if err != nil {
			return fmt.Errorf("cmd goda run: %w", err)
		}

		return nil
	},
	)

	var image []byte
	eg.Go(func() error {
		log.Println("generate dependency graph")
		cmdGraphviz := exec.Command("dot")
		if cmdGraphviz.Err != nil {
			return fmt.Errorf("command graphviz: %w", cmdGraphviz.Err)
		}

		cmdGraphviz.Args = append(cmdGraphviz.Args, "-T", "svg")
		cmdGraphviz.Stdin = godaOutputReader
		// TODO: why not return in error? Same for other commands.
		cmdGraphviz.Stderr = os.Stderr

		output, err := cmdGraphviz.Output()
		if err != nil {
			return fmt.Errorf("graphviz output '%s': %w", string(output), err)
		}

		image = output

		log.Println("dependency graph generated")

		return nil
	},
	)

	err = eg.Wait()
	if err != nil {
		return nil, fmt.Errorf("failed errgroup: %w", err)
	}

	return image, nil
}

func pasteDepsToHTML(treeHTML []byte, depsGraph []byte) ([]byte, error) {
	// Cut everything before <svg> tag since graphviz generates some basic html elements.
	// We already have basic html in page generated by 'tree' util.
	_, svgHTML, ok := strings.Cut(string(depsGraph), "<svg")
	if !ok {
		svgHTML = string(depsGraph)
	}
	// Add id to identify later.
	svgHTML = `<svg id="svg" ` + svgHTML

	// Overflow:auto allows to fit tree and graph with scroll
	// to viewports with desired width and height.
	// White-space:nowrap tells not to wrap words, makes tree more readable.
	// Vertical-align: top was needed to place content on top, not in the center of row.
	htmlTableStart := `
	<body>
	<style>
	#container {
	  width: 75lvw;
	  height: 90lvh;
	  overflow: auto;
	}
	#tree-container {
		width: 20lvw;
		height: 90lvh;
		overflow: auto;
	  }
 </style>
	<table style="width=100%">
		<tr>
		  <th style="white-space:nowrap; overflow:auto; vertical-align:top;">Directory Tree</th>
		  <th>Packange Dependecy Graph</th>
		</tr>
		<tr>
		<td style="white-space:nowrap; overflow:auto; vertical-align:top;">
		<div id="tree-container">`

	htmlTableGraphPart := fmt.Sprintf(`
	</div>
	</td>
  <td style="vertical-align:top;">
	<div id="container">
		%s
	</div>
	<button id="zoom-in">zoom in</button>
	<button id="zoom-out">zoom out</button>
  </td>
</tr>
</table>
<script>
// TODO: doesn't work since we remove attributes later (width, height)
// think about good scroll/resize/focus mechanics
const svg = document.querySelector('#svg');

const btnZoomIn = document.querySelector('#zoom-in');
const btnZoomOut = document.querySelector('#zoom-out');

btnZoomIn.addEventListener('click', () => {
    resize(1.1);
});

btnZoomOut.addEventListener('click', () => {
    resize(0.9);
});

function resize(scale) {
    let svgWidth = parseInt(svg.getAttribute('width'));
    svg.setAttribute('width', `+"`${(svgWidth * scale)}`"+`);
    let svgHeight = parseInt(svg.getAttribute('height'));
    svg.setAttribute('height', `+"`${(svgHeight * scale)}`"+`);
}

// For wider picture angle
// TODO: maybe remove
svgCnvs = document.getElementById('svg')
svgCnvs.removeAttribute('width')
svgCnvs.removeAttribute('height')

// This class allows to zoom in to graph node on tree element click.
// it works almost good, but there's a lot of things to do:
// TODO: 
// - add opportunity to scroll left and right after focus
// - not really good at big projects like kubernetes, 
//  sometimes need to click twice to zoom properly. 
//  Probably caused by zoom reset before zoom apply. Need to investigate.
class SVGZoomController {
	constructor(svgElement, containerElement, options = {}) {
		this.svg = svgElement;
		this.container = containerElement;
		this.initialViewBox = this.parseViewBox(this.svg.getAttribute('viewBox'));
		this.currentViewBox = {...this.initialViewBox};
		this.zoomFactor = options.zoomFactor || 1.5;
		this.maxZoomLevel = options.maxZoomLevel || 5;
		this.zoomLevel = 0;
		this.animationDuration = options.animationDuration || 300;
		
		this.init();
	}
	
	parseViewBox(viewBoxStr) {
		const parts = viewBoxStr.split(' ').map(Number);
		return {
			x: parts[0],
			y: parts[1],
			width: parts[2],
			height: parts[3]
		};
	}
	
	init() {
		this.svg.addEventListener('click', (e) => {
			if (e.target.tagName !== 'svg') {
				this.zoomToElement(e.target);
			}
		});
		
		document.getElementById('resetZoom')?.addEventListener('click', () => this.resetZoom());
	}
	
	zoomToElement(element) {
		if (this.zoomLevel >= this.maxZoomLevel) return;

		// Otherwise second zoom will be weird.
		this.resetZoom();
		
		const bbox = element.getBBox();
		// GraphViz nodes have negative Y. But if we sustract modulus Y from the height, 
		// we obtain desired positive value.
        if (bbox.y < 0) {
            bbox.y = this.currentViewBox.height + bbox.y
        }

		const centerX = bbox.x + bbox.width / 2;
		const centerY = bbox.y + bbox.height / 2;
		
		// Calculate new viewBox
		const newWidth = this.currentViewBox.width / this.zoomFactor;
		const newHeight = this.currentViewBox.height / this.zoomFactor;
		
		const newViewBox = {
			x: centerX - newWidth / 2,
			y: centerY - newHeight / 2,
			width: newWidth,
			height: newHeight
		};
		
		// Animating viewBox change
		this.animateViewBox(this.currentViewBox, newViewBox);
		
		this.currentViewBox = newViewBox;
		this.zoomLevel++;
		
		// After animation fix scroll
		setTimeout(() => {
			this.adjustScrollPosition(bbox);
		}, this.animationDuration);
	}
	
	animateViewBox(from, to) {
		const startTime = performance.now();
		const duration = this.animationDuration;
		
		const animate = (currentTime) => {
			const elapsed = currentTime - startTime;
			const progress = Math.min(elapsed / duration, 1);
			
			const interpolated = {
				x: from.x + (to.x - from.x) * progress,
				y: from.y + (to.y - from.y) * progress,
				width: from.width + (to.width - from.width) * progress,
				height: from.height + (to.height - from.height) * progress
			};
			
			this.svg.setAttribute('viewBox', 
				`+"`${interpolated.x} ${interpolated.y} ${interpolated.width} ${interpolated.height}`"+`);
			
			if (progress < 1) {
				requestAnimationFrame(animate);
			}
		};
		
		requestAnimationFrame(animate);
	}
	
	adjustScrollPosition(bbox) {
		// Obtain element position relative to container
		const svgRect = this.svg.getBoundingClientRect();
		const containerRect = this.container.getBoundingClientRect();
		
		// Calculate center of the element
		const elementCenterX = bbox.x + bbox.width / 2;
		const elementCenterY = bbox.y + bbox.height / 2;
		
		// Convert SVG coordinates to viewport coordinates
		const viewBox = this.currentViewBox;
		const scaleX = svgRect.width / viewBox.width;
		const scaleY = svgRect.height / viewBox.height;
		
		const viewportX = (elementCenterX - viewBox.x) * scaleX;
		const viewportY = (elementCenterY - viewBox.y) * scaleY;
		
		// Calculate new scroll position
		const targetScrollLeft = viewportX + svgRect.left - containerRect.left - containerRect.width / 2;
		const targetScrollTop = viewportY + svgRect.top - containerRect.top - containerRect.height / 2;
		
		// Smoothly scroll to the desired position
		this.container.scrollTo({
			left: targetScrollLeft,
			top: targetScrollTop,
			behavior: 'smooth'
		});
	}
	
	resetZoom() {
		this.animateViewBox(this.currentViewBox, this.initialViewBox);
		this.currentViewBox = {...this.initialViewBox};
		this.zoomLevel = 0;
		
		// Reset scroll to the begining
		setTimeout(() => {
			this.container.scrollTo({
				top: 0,
				left: 0,
				behavior: 'smooth'
			});
		}, this.animationDuration);
	}

}


// Init after DOM loaded
document.addEventListener('DOMContentLoaded', () => {
	// Init zoomer
	const svg = document.getElementById('svg');
	const container = document.getElementById('container');
	const zoomController = new SVGZoomController(svg, container, {
		zoomFactor: 2,
		maxZoomLevel: 8,
		animationDuration: 300
	});

	// Gather all graph nodes to match them with tree nodes.
	// This is dirty hacks because I used 'tree' util to generate inital html.
	// When there will be native go tree generation, this code will be or refactored.
	var graphNodes = document.querySelectorAll('g[class="node"]');
	var nodeTitles = {};
	for (var i = 0; i < graphNodes.length; i++) {
		title = graphNodes[i].childNodes[1].innerHTML.replace(/"/g, '');
		nodeID = graphNodes[i].id;
		nodeTitles[title] = nodeID;
	}

	// Create map with [tree node id] graph node id
	var anchors = document.getElementsByTagName('a');
	var treeGraphMap = {};
	for (var i = 0; i < anchors.length; i++) {
		const anchor = anchors[i];
		if (anchor.className == "DIR") {
			relativePackagePath = anchor.getAttribute('href').slice(1, -1);
			anchor.removeAttribute('href')
			anchor.setAttribute('id', relativePackagePath)

			found = false;
			for (const packagePath in nodeTitles) {
				if (packagePath.endsWith(relativePackagePath)) {
					const nodeID = nodeTitles[packagePath];
					treeGraphMap[anchor.id] = nodeID

					found = true;
					
					break;
				}
			}
		}
	}

	// Set element tree click action - zoom and highlight
	for (var i = 0; i < anchors.length; i++) {
		const anchor = anchors[i];
		anchor.onclick = function() {
			graphNodeID = treeGraphMap[anchor.id];

			graphNode = document.getElementById(graphNodeID);
			if (!graphNode) {
				// For a while print alert. Later create differen color
				// for simple directories (not packages).
				alert(`+"`${anchor.id}`"+` + " is not a package");
				return;
			}
			zoomController.zoomToElement(graphNode);

			polygon = graphNode.getElementsByTagName("polygon")[0];
			originFill = polygon.getAttribute("fill");
			polygon.setAttribute("fill", "red");

			setTimeout(() => {
				polygon.setAttribute("fill", originFill);
			  }, "1000");
			  
		};
	}
});

</script>`, svgHTML)

	stringHTML := string(treeHTML)

	// Remove needless elements from 'tree' html output.
	// Will be redundant when use template or something like that.
	stringHTML = strings.Replace(stringHTML, "<h1>Directory Tree</h1>", "", 1)
	stringHTML = strings.Replace(stringHTML, "<p>", "", 1)
	stringHTML = strings.Replace(stringHTML, `<\p>`, "", 1)

	// Paste page style block and tree style block
	stringHTML = strings.Replace(
		stringHTML,
		"<body>",
		htmlTableStart,
		1,
	)

	// Paste graph html
	stringHTML = strings.Replace(
		stringHTML,
		"</body>",
		htmlTableGraphPart,
		1,
	)

	return []byte(stringHTML), nil
}
